<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <!-- 
  Document : FunctionalSpec
  Created on : Nov 17, 2008, 4:25:47 PM
  Author : ken
  -->
  <title>JMXA Functional Spec</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <style type="text/css" title="Amaya theme">
/* Modern style for Amaya Editor Lite */

/* default rules for the whole document */
body {
    font-size: 12pt;
    font-family: Helvetica, Arial, sans-serif;
    font-weight: normal;
    font-style: normal;
    color: black;
    background-color: white;
    line-height: 1.2em;
    margin-left: 4em;
    margin-right: 2em;
   }

/* paragraphs */
p  {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }

/* headings */
h1 {
    font-size: 180%;
    font-weight: bold;
    font-style: normal;
    font-variant: small-caps;
    text-align: left;
    padding: 0;
    margin-top: 1.7em;
    margin-bottom: 1.7em;
   }
h2 {
    font-size: 150%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.5em;
    margin-bottom: 1.1em;
   }
h3 {
    font-size: 130%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.3em;
    margin-bottom: 1.1em;
   }
h4 {
    font-size: 110%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.1em;
    margin-bottom: 1.1em;
   }
h5 {
    font-size: 100%;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }
h6 {
    font-size: 100%;
    font-weight: normal;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }

/* divisions */
div {
    padding: 0;
    margin-top: 0em;
    margin-bottom: 0em;
   }

/* lists */
ul, ol {
    padding: 0 0 0 3em;
    margin-top: 1em;
    margin-bottom: 1em;
   }
ul ul, ol ol, ul ol, ol ul {
    margin-top: 1em;
    margin-bottom: 1em;
   }
li {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }
li p {
    margin-top: 1em;
    margin-bottom: 1em;
   }
dl {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 1em;
   }
dl dl {
    margin-top: 0em;
    margin-bottom: 0em;
   }
dt {
    padding: 0;
    font-weight: bold;
    margin-top: .3em;
    margin-bottom: .3em;
   }
dd {
    padding: 0;
    margin-top: .3em;
    margin-left: 3em;
    margin-bottom: .3em;
   }
dl p {
    margin-top: .3em;
    margin-bottom: .3em;
   }

/* inline */
strong {
    font-weight: bold;
   }
em {
    font-style: italic;
   }
code {
    font-family: Courier New, Courier, monospace;
   }
ins {
    background-color: yellow;
    text-decoration: underline;
   }
del {
    text-decoration: line-through;
   }

/* anchors */
a[href] {
    color: blue;
    text-decoration: underline;
   }

/* end */
  </style>
</head>

<body>
<h1>GlassFish MBean Annotation Library (gmbal)</h1>

<h1>Functional Specification</h1>
by Ken Cavanaugh<br>
Spec version .30<span style="background-color:#faffdd"></span><br>
12/05/08<span style="background-color: #fff9c8;"></span><br>


<h2>1. Introduction</h2>

<p>The GlassFish MBean Annotation Library (gmbal, pronounced as in "gumball")
is a runtime annotation processor that creates Open MBeans. This is useful for
creating a management API for existing code with minimal effort.  It is
intended to be applied to existing modules (which may be OSGi bundles in
GlassFish v3, or any other packaging model including standard jar files), but
could be used anywhere that it is desired to combine the definition of the
management API with the module API and implementation.</p>

<p>Note that gmbal is not limited to use in GlassFish. Gmbal is
completelyindependent of GlassFish, and may be used in a context where
GlassFIsh is not present. However, when a gmbal-enabled module in used in
GlassFish V3, that module will automatically be manageable using GlassFish V3
admin tools.</p>

<p>There are really two parts to creating a management API for a module:
instrumenting the module implementation, and providing a client interface that
may be accessed remotely.  This is what AMX has done in GlassFish, and gmbal
will follow the same model.<br>
<br>
The details on the client model still need to be worked out, but basically
gmbal will generate Java interfaces from annotated classes to provide
client-side proxies for remote access to the gmbal-generated MBeans. The
proxies will take care of mapping MBean ObjectNames to a type-specific
interface that extends the AMX interface, mapping OpenTypes to
application-domain types (e.g. map CompositeData to a Java class containing
getters for its various data elements), and any other details that make the
client side API simple to use.<br>
<br>
The source code generation will be in two parts:<br>
</p>
<ol>
  <li>A set of interfaces for MBean and OpenType definitions that can have as
    extensive JavaDocs written as needed. The description information will be
    filled in as a default and starting point for the JavaDocs. This should be
    generated once and maintained separately  to preserve the JavaDocs, rather
    than generated for each build.<br>
  </li>
  <li>A set of implementations of the interfaces that is generated for each
    build. This will detect inconsistencies between the interfaces and
    implementations.</li>
</ol>
The source code generation will be driven from the meta data produced by
analyzing the classes, using the same code. The tool itself will be packaged
separately from the main implementation, since it is only needed at build
time.<br>


<h3>1.1. Alignment with related projects</h3>
JMX is also defining similar annotations in JSR 255 for JDK 7.  You can obtain
the spec from the download <a
href="http://jcp.org/aboutJava/communityprocess/edr/jsr255/index.html">page</a>.
Gmbal is mostly (but not completely) aligned with the JSR 255 annotations. 
<br>
<br>
The similarities include:<br>

<ul>
  <li><a
    href="dist/javadoc/org/glassfish/gmbal/ManagedAttribute.html">@ManagedAttribute</a>
    is the same, except that gmbal allows overriding the id.</li>
  <li><a
    href="dist/javadoc/org/glassfish/gmbal/ManagedOperation.html">@ManagedOperation</a>
    is the same, except that gmbal allows overriding the id.</li>
  <li><a
    href="dist/javadoc/org/glassfish/gmbal/Descriptor.html">@DescriptorKey</a>
    is the same.</li>
  <li><a
    href="dist/javadoc/org/glassfish/gmbal/DescriptorFields.html">@DescriptorFields</a>
    is the same.</li>
  <li><a
    href="dist/javadoc/org/glassfish/gmbal/Description.html">@Description</a>
    is similar, but gmbal only has a value() attribute, while JSR 255 has key
    and bundleBaseName. Gmbal takes the approach that I18N support is handled
    by using keys on the annotation only, then providing a separate resource
    bundle which can be registered with the <a
    href="dist/javadoc/org/glassfish/gmbal/ManagedObjectManager.html">ManagedObjectManager</a>
    (see the discussion <a
    href="#MBeanServer_and_ResourceBundle">below</a>).<br>
  </li>
</ul>
Differences:<br>

<ul>
  <li>The packaging is necessarily different: org.glassfish.gmbal for gmbal,
    javax.management for JSR 255.</li>
  <li>Gmbal uses <a
    href="dist/javadoc/org/glassfish/gmbal/ManagedObject.html">@ManagedObject</a>
    instead of @MBean (part of JSR 255) or <a
    href="http://java.sun.com/javase/6/docs/api/javax/management/MXBean.html">@MXBean</a>.</li>
  <li>Gmbal only support attribute change notifications (so far), so the
    @NotificationInfo annotation (from JSR 255) does not exist in Gmbal.</li>
  <li>Gmbal has an <a
    href="dist/javadoc/org/glassfish/gmbal/ManagedData.html">@ManagedData</a>
    annotation to define the mapping of data types into CompositeData, while
    JSR 255 follows MXBeans and simply assumes that all methods that follow the
    JavaBeans patterns define read-only attributes.</li>
  <li>Gmbal supports an <a
    href="dist/javadoc/org/glassfish/gmbal/MBeanType.html">@MBeanType</a>
    annotation, but this is really just an extension to the descriptor
    annotation mechanism borrowed from JMX ModelMBeans.  The @MBeanType
    annotation is provided to support AMX-specific metadata.</li>
  <li>Gmbal includes <a
    href="dist/javadoc/org/glassfish/gmbal/ParameterNames.html">@ParameterNames</a>
    to provide reasonable names for the arguments on MBean operations.  JSR
    255 does not currently have such a mechanism, because JDK 7 will have an
    extension to Java reflection that captures the argument names on
  methods.</li>
  <li>Gmbal includes <a
    href="dist/javadoc/org/glassfish/gmbal/ObjectNameKey.html">@ObjectNameKey</a>
    to make it easy to define the value of the "name" field in the ObjectName.
    This makes registration of object as MBeans slightly simpler.</li>
  <li>Gmbal includes <a
    href="dist/javadoc/org/glassfish/gmbal/IncludeSubclass.html">@IncludeSubclass</a>,
    which allows limited (and closed) polymorphism for CompositeData.  This
    partially solves the problem of mapping a group of types sharing type Base
    that appear as (for example) attributes with type List&lt;Base&gt;.</li>
  <li>Gmbal includes <a
    href="dist/javadoc/org/glassfish/gmbal/InheritedAttribute.html">@InheritedAttribute</a>(<a
    href="dist/javadoc/org/glassfish/gmbal/InheritedAttributes.html">s</a>) to
    allow using methods inherited from super classes or super interfaces that
    cannot be annotated as attribute and operations.</li>
  <li>Gmbal is more limited currently in mapping OpenType -&gt; Java type than
    JMX is, as this does not seem to be a feature that we need.<br>
  </li>
</ul>
Note that there are two complimentary ways to define MBeans: MXBeans and
annotations.  MXBeans are somewhat more convenient to use in cases where EVERY
method in a class or interface is part of the management interface, whereas
annotations are more convenient for adding a management interface to existing
code. But both mechanisms share most of the same rules for MXBean mapping from
Java types to Open types as discussed in "xxx".<br>
<br>
AMX in GlassFish v3 is being generalized to define exactly what an MBean must
do to be manageable in the GlassFish v3 admin tools (see Lloyd's <a
href="https://glassfish.dev.java.net/nonav/v3/admin/planning/V3Changes/V3_AMX_SPI.html">GlassFish
V3 AMX SPI</a> specification). Gmbal will follow all mandatory and most of the
optional requirements of this specification so that any module that uses gmbal
to define MBeans will automatically participate in the GFv3 admin console and
CLI when run in a GFv3 container.  However, this will not prevent the use of
gmbal in these same modules as a standalone MBean definition library.<br>
<br>
This last point needs a little more explanation.  The main interface that
matters for running in or out of a GFv3 container is
ManagedObjectManagerFactory.createXXX (XXX is either Standalone or Federated).
The createStandalone method is needed for running outside of GFv3, and takes
the domain name as an argument. createFedederated must be called inside of
GFv3, and this require the ObjectName of the ManagedObjectManager root MBean's
parent.  Calling the appropriate method is probably best handled in many cases
by having a OSGi bundle for a module that is responsible for integrating the
module into GFv3.  For example, the ORB will need such a module to handle
registration of all of the GFv3-specific interceptors and other initialization
when the GFv3 ORB instance is created.<br>


<h3>1.2. Similar projects</h3>
I have already discussed JSR 255 in the previous section, but there are other
projects that also define MBeans using annotations.<br>
<br>
The Spring project also defines a set of annotations to use for creating
MBeans.  Eamonn McManus has pointed<br>
to this as one of the starting points for JSR 255 in a blog <a
href="http://weblogs.java.net/blog/emcmanus/archive/2007/08/defining_mbeans.html">post</a>
from August 2007.  JSR 255 and Spring share the<br>
@ManagedAttribute and @ManagedOperation annotations, but the Spring annotations
include a description fields,<br>
whereas JSR 255 has moved the description into a separate annotation (as I have
in gmbal as well).<br>
<br>
The WebObject project from INRIA in France has created the <a
href="http://spoon.gforge.inria.fr/SpoonJMX/Main">SpoonJMX</a> project, which
also allows the use of annotations<br>
to define MBeans. SpoonJMX uses @ManagedResource to define an MBean class.  It
uses @ManagedAttribute and @ManagedOperation<br>
as in the other systems.  SpoonJMX defines the @ObjectNameKey annotation,
which I have adopted for use in<br>
gmbal as well.  SpoonJMX also defines more attributes on the annotations than
either gmbal or JSR 255.<br>


<h2>2. The Management Data Model</h2>
Gmbal supports a simple hierarchical model of management data as defined in JSR
77 and AMX.<br>
<img style="width: 730px; height: 507px;" alt="JMXA Class Diagram"
src="JMXA.png"><br>
The components of the data model are as follows:<br>

<ul>
  <li>A ManagedObjectManager acts as a container for all state related to a
    particular usage of gmbal. This includes:
    <ul>
      <li>A domain to use for all ObjectNames created in this
        ManagedObjectManager</li>
      <li>A rootParentName, which is the ObjectName of the parent of the
        ManagedObjectManager</li>
      <li>A root object, which represents the top of the tree of MBean managed
        by the ManagedObjectManager<br>
      </li>
    </ul>
  </li>
  <li>From a POJO with annotations, an MBeanImpl is constructed.  An MBeanImpl
    has a number of objects associated with it:
    <ul>
      <li>0 or more Attributes, which may be getters or setters or both</li>
      <li>0 or more Operations, which may be invoked</li>
      <li>Metadata, represented by ModelMBeanInfoSupport (so that metadata
        Descriptors are available on JDK 5 as well as JDK 6)</li>
      <li>A single parent MBeanImpl, which may be null (this is one end of the
        contains relation)</li>
      <li>0 or more child MBeanImpls (this is the other end of the contains
        relation)</li>
      <li>Following JSR 77, a type and a name String, which together with the
        ObjectName of the parent are used to form the ObjectName of the
        MBeanImpl<br>
      </li>
    </ul>
  </li>
  <li>Attributes and Operations have ids</li>
</ul>
Note that all values consumed or produced by Attributes and Operations are
instances of OpenTypes.<br>
<br>
This diagram is a simplification of the actual implementation of gmbal.  In
particular, <br>
the metadata, attributes, and operations are maintained in a MBeanSkeleton
class, which is<br>
shared by all MBeanImpls for instances of the same class.  The TypeConverter
that handles<br>
conversion between Java types and the corresponding OpenType is also not
included here.<br>


<h2>3. Interfaces</h2>
Javadocs are <a href="dist/javadoc/index.html">available</a> as part of the
gmbal project.  <br>
<br>
There are basically 3 elements to the gmbal API:<br>

<ol>
  <li>class ManagedObjectManagerFactory, which provides factory methods for
    creating instance of the ManagedObjectManager interface.</li>
  <li>interface ManagedObjectManager, which provides register/deregister
    methods (and a number of other capabilities).</li>
  <li>A number of annotations.<br>
  </li>
</ol>
Here is a summary of the annotations:<br>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Annotation Class<br>
      </td>
      <td
        style="vertical-align: top; font-weight: bold; width: 25%;">Annotation
        Fields<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Applicable Element
        Type<br>
      </td>
      <td style="vertical-align: top;"><span
        style="font-weight: bold;">Relation to JSR 255</span><br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Purpose<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedObject<br>
      </td>
      <td style="vertical-align: top;">none<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">255 uses @MXBean<br>
      </td>
      <td style="vertical-align: top;">Defines a class whose instances are
        processed into MBeans.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedData<br>
      </td>
      <td style="vertical-align: top;">String name (defaults to class name)<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">MXBeans assume all methods are in
        CompositeData<br>
      </td>
      <td style="vertical-align: top;">Defines a class whose instances are
        process into Open data for Open Mbeans.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedAttribute<br>
      </td>
      <td style="vertical-align: top;">String id (defaults to value from Method
        name)<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">Same<br>
      </td>
      <td style="vertical-align: top;">Defines a method that represents an
        attribute either in ManagedData or ManagedObject<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedOperation<br>
      </td>
      <td style="vertical-align: top;">String id (defaults to value from Method
        name)<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">Same<br>
      </td>
      <td style="vertical-align: top;">Defines a method that represents an
        operation in ManagedObject <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@Description<br>
      </td>
      <td style="vertical-align: top;">String value<br>
      </td>
      <td style="vertical-align: top;">Class, Interface, or Method<br>
      </td>
      <td style="vertical-align: top;">Same (but JSR 255 includes I18N)<br>
      </td>
      <td style="vertical-align: top;">Defines the descriptive text associated
        with a Class, Interface, or Method<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@IncludeSubclass<br>
      </td>
      <td style="vertical-align: top;">Class[] value<br>
      </td>
      <td style="vertical-align: top;">Class or Interface for ManagedData<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Lists subclasses of the annotated class
        that should also be scanned for annotations which are included only on
        instances of the appropriate type<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ObjectNameKey<br>
      </td>
      <td style="vertical-align: top;">none<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Defines a method (must be a getter)
        whose result is the name of the MBean for an instance of the class<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ParameterNames<br>
      </td>
      <td style="vertical-align: top;">String[] value (defaults to "") (if
        present, must have same length as number of arguments in the annotated
        method)<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">N/A (JSR 255 will take this information
        from reflection, which will make arg names available in JDK 7)<br>
      </td>
      <td style="vertical-align: top;">Defines the method names to be used on
        an MBean operation<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@InheritedAttribute<br>
      </td>
      <td style="vertical-align: top;"><ul>
          <li>String description</li>
          <li>String id (default "" which means take from method name)</li>
          <li>String methodName (default "" which means use id)</li>
          <li>one of methodName or id must NOT be ""<br>
          </li>
        </ul>
        <br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Defines a method inherited from a class
        that cannot be annotated as an attribute<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@InheritedAttributes<br>
      </td>
      <td style="vertical-align: top;">InheritedAttribute[] value<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Allows including multiple inherited
        attributes<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@MBeanType<br>
      </td>
      <td style="vertical-align: top;"><ul>
          <li>String pathPart (the type to use in an ObjectName or in an admin
            CLI path expression:  defaults to class name, but see also  <a
            href="#addTypePrefix">addTypePrefix</a>)</li>
          <li>boolean isLeaf (true if this MBean can not contain other
          MBeans)</li>
          <li>boolean isSingleton (true  if only one MBean of this type is
            allowed as a child of  another MBean)</li>
          <li> boolean isMBeanInfoInvariant (true if the MBeanInfo can never
            change)</li>
          <li>String pathPart (value to use in AMX CLI commands: defaults to
            type)</li>
          <li>String group() (value is the group for this mbean, defaults to
            "other")</li>
          <li>String[] subTypes() (value is the list of allowable types for
            children of this bean)<br>
          </li>
        </ul>
         (This is just an application of @DescriptionKey, with a little
        special support in the gmbal implementation)<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">N/A (but JMX supports descriptors; see
        below)<br>
      </td>
      <td style="vertical-align: top;">Adds GFv3 and AMX specific metadata to
        be defined for MBeans<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@DescriptionKey<br>
      </td>
      <td style="vertical-align: top;">String value<br>
      </td>
      <td style="vertical-align: top;">Annotation method<br>
      </td>
      <td style="vertical-align: top;">same as JSR 255<br>
      </td>
      <td style="vertical-align: top;">Define metadata that can be added to any
        MBean<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@DescriptionField<br>
      </td>
      <td style="vertical-align: top;">String value (must be name=value)<br>
      </td>
      <td style="vertical-align: top;">Class, Interface, or Method<br>
      </td>
      <td style="vertical-align: top;">same as JSR 255<br>
      </td>
      <td style="vertical-align: top;">Define metadata directly on MBean<br>
      </td>
    </tr>
  </tbody>
</table>
<br>


<h3>3.1. The ManagedObjectManagerFactory</h3>
The ManagedObjectManagerFactory is primarily used to create
ManagedObjectManagers.  It is the only concrete class in the gmbal API.<br>


<h4>3.1.1. getMethod</h4>
This is a simple wrapper around Class.getDeclaredMethod that converts the
checked exceptions from getDeclaredMethod into unchecked exceptions.  It is
intended for use with the <a href="#addAnnotation">addAnnotation</a> method.<br>
See also the <a href="#What_if_you_cannot_add_an_annotation">discussion</a>
about adding annotations.<br>


<h4>3.1.2. create</h4>
There are two versions of create: create( String ) and create( ObjectName ). 
create( String ) is used to create a standalone hierarchy: the String is the
domain to use for all ObjectNames created from the resulting
ManagedObjectManager.  In this version, the root has no parent.<br>
<br>
create( ObjectName ) is used to create a hierarchy of MBeans that are rooted
under a parent MBean that is not managed by the created instance of
ManagedObjectManager.  In this case, the parent of the ManagedObjectManager is
identified by the object name (called the rootParentName) that is passed to the
create call.  Note that the root parent MBean MUST be managed by the same
MBeanServer as the ManagedObjectManager.<br>


<h3>3.2. The ManagedObjectManager</h3>
The ManagedObjectManager is the main API for gmbal.  It contains a tree of
MBeans with a single root,<br>
which may optionally be federated into a large MBean hierarchy.<br>
<br>
The most important methods are createRoot, register, and unregister.  Any
application of gmbal must use these methods.  <br>


<h4>3.2.1. createRoot</h4>
There are several methods to create a root in the ManagedObjectManager. 
createRoot() creates a root that simply acts as an AMX container.  Its type
and name are both set to GMBALROOT.<br>
<br>
createRoot( Object ) and createRoot( Object, String ) both use the given object
as the root, and just as in the register methods, these methods create an MBean
from the Object using the annotations on its class. The createRoot( Object )
method will derive the name from the object itself by calling the
@ObjectNameKey method from the class.  If no such method is available, the
name is set to the type value.  The second method allows the name to specified
explicitly.  This can be useful in case where either @ObjectNameKey is not
used, or there are multiple ManagedObjectManager instances with the same root
type that share the same parent.  In this case, it is essential that each root
have a distinct name.last<br>
<br>
createRoot may only be called when the ManagedObjectManager does not already
contain a root. This is true immediately after a
ManagedObjectManagerFactory.create call, or after unregistering the root.<br>


<h4>3.2.2. getRoot</h4>
getRoot returns the current root of the ManagedObjectManager.  If no root is
available, getRoot throws an IllegalStateException.<br>


<h4>3.2.3. register and registerAtRoot</h4>
There are two forms of register: register( Object parent, Object obj ) and
register( Object parent, Object obj, String name ).  The first form obtains
the name from obj (either via @ObjectNameKey, or by default using the type),
the second allows explicit specification.  The returned result is an instance
of NotificationEmitter that may be used to register a NoticationListener to
listen for attribute change notifications on that particular MBean.  <br>
<br>
There are also two forms of registerAtRoot: registerAtRoot( Object obj ) and
registerAtRoot( Object obj, String name).  These methods are exactly
equivalent to mom.register( mom.getRoot(), obj ) and mom.register(
mom.getRoot(), obj, name ).<br>


<h4>3.2.4. unregister</h4>
unregister( Object ) unregisters an object that was previously registered.  It
also deletes any children of the object in depth-first order.  Unregister
removes the generated MBean from the ManagedObjectManager and also unregisters
the MBean from the ManagedObjectManager's MBeanServer.<br>


<h4>3.2.5. getObject/getObjectName</h4>
The register methods return a NotificationEmitter which can be used to register
a NotificationListener to listen for attribute change events.  But sometimes
access to the ObjectName is needed.  getObjectName returns the ObjectName that
was created for an object that was passed to the register method.  getObject
is used to handle the opposite case: going from the ObjectName to the
registered Object.  Note that in both case the registered Object is the
implementation object passed to a register method, NOT the internally created
dynamic MBean (which is not directly provided).<br>


<h4>3.2.6. <a name="addTypePrefix"></a>addTypePrefix</h4>
A type prefix is simply a prefix of a fully qualified Java class name. By
default, the MBean ObjectName type field is set to the full qualified class
name of the implementation class, stripped of the longest type prefix of the
class name.  For example, in CORBA the type prefixes are set to:<br>
<br>


<div style="margin-left: 40px;">
com.sun.corba.se<br>
com.sun.corba.se.spi<br>
com.sun.corba.se.spi.orbutil<br>
com.sun.corba.se.impl<br>
com.sun.corba.se.impl.orbutil<br>
<br>
</div>
This helps keep the ObjectNames to a reasonable length.  Applications of gmbal
are also free to specify the exact type name to use through an annotation.<br>


<h4>3.2.7. <a name="MBeanServer_and_ResourceBundle"></a>MBeanServer and
ResourceBundle</h4>
Accessors (getter and setter) are provided for the MBeanServer and the
ResourceBundle.<br>
<br>
The MBeanServer is used for all register and unregister operations in the
ManagedObjectManager instance. It defaults to the<br>
platform MBeanServer.<br>
<br>
The ResourceBundle is used to internationalize all descriptions.  If set, the
description value is used as a key in the resource bundle,<br>
otherwise the description value is taken as the actual description.<br>


<h4>3.2.8. <a name="addAnnotation"></a>addAnnotation</h4>
The best way to explain this method is to start with an example.  CORBA
defines a class org.omg.PortableServer.Servant.  <br>
The definition of Servant is a standard, and so I cannot add annotations to the
source code for Servant.  Gmbal is flexible<br>
enough that we can put the annotation almost anywhere, so what are the possible
subclasses of Servant?<br>
Mostly one subclass is used in GlassFish for dynamic RMI-IIOP: ReflectiveTie,
but others are possible, including<br>
Ties generated by the idlj compiler.  We also cannot add non-standard
annotations to standard-compliant code generated<br>
by a code generator.<br>
<br>
This becomes an issue when adding annotations to things like the ORB's POA,
which has a method:<br>

<pre>@ManagedData<br>Servant get_servant() { ... }<br></pre>
that I would like to use as an attribute.  How should gmbal represent Servant
in this case?  I may want to represent<br>
the Servant as ManagedData, using one or more methods (such as byte[]
_object_id()) on the Servant as attributes,<br>
but there is no place that I can put an annotation for this.<br>
<br>
The solution I have adopted in gmbal is to allow annotations to be added on
"dummy" classes, and then use <br>
ManagedObjectManager.addAnnotation to add the annotation to the appropriate
type.  For example, the above example<br>
can be handled by:<br>
<br>

<pre>@ManagedData<br>@InheritedAttributes( {<br>    @InheritedAttribute( methodName="_object_id", id="objectId",<br>        description="The Object Id for this Servant" ),<br>    ... // several other methods<br>} )<br>public interface DummyServant {}<br><br>mom.addAnnotation( Servant.class, DummyServant.class.getAnnotation( ManagedObject.class ) ) ;<br>mom.addAnnotation( Servant.class, DummyServant.class.getAnnotation( InheritedAttributes.class ) ) ;<br></pre>
This behaves exactly as if the annotations on DummyServant were on Servant,
allowing the appropriate <br>
annotation processing to take place.<br>
<br>
InheritedAttribute can also be used when it is desired to use a method
inherited from a super class as<br>
an attribute or operation.  This is useful in the case where the superclass is
a class that for whatever<br>
reason cannot be modified with an annotation.<br>


<h4>3.2.9. Debugging support</h4>
Gmbal is a fairly complex system, and it is possible to apply it in ways that
lead to incorrect results.<br>
To help with this, I have defined several features that can be useful for
debugging:<br>

<ul>
  <li>setRegistrationDebugLevel( RegistrationDebugLevel level ).  Here the
    level can be NONE, NORMAL, or FINE.  When enabled, this method causes
    detailed tracing (more detailed with FINE) of the operations involved in
    registering an MBean.</li>
  <li>setRuntimeDebugLevel( boolean flag ).  If this is enabled, the
    operations involved in getting or setting attributes or calling an
    operation on an MBean are traced.</li>
  <li>String dumpSkeleton( Object obj ).  If obj is an object that has been
    registered with the ManagedObjectManager, this returns a String dump of the
    MBeanSkeleton object, which provides detailed information about the exact
    attributes and operations supported by the MBean.</li>
</ul>
These operations can be used to get useful information about the operation of
gmbal.  The setXXXDebugLevel methods currently dump<br>
information to System.out, but the code has a flag that can be set to dump
information to a Logger.  The Logger may become the <br>
default dump mechanism in the future.<br>


<h2>4. Further notes on the API<br>
</h2>
There are a number of details about how the APIs work that require further
discussion.<br>


<h3>4.1. Processing of method names for IDs</h3>
The following rules are applied to generate attribute and operation IDs from
method names:<br>
<br>

<ol>
  <li>If the method is annotated with @ManagedAttribute:<br>

    <ol>
      <li>If the method is a getter (that is, it has no arguments and a
        non-void result):
        <ol>
          <li>If the method name starts with "get", remove "get" and make the
            next letter lowercase.</li>
          <li>If the return type is boolean, and the method starts with "is",
            remove "is" and make the next letter lowercase.</li>
          <li>Otherwise the method name is the id.<br>
          </li>
        </ol>
      </li>
      <li>If the method is a setter (that, has one argument and a void result):
        <ol>
          <li>If the method name starts with "set", remove "set" and make the
            next letter lowercase.</li>
          <li>Otherwise the method name is the id.</li>
        </ol>
      </li>
      <li>Otherwise the method is not a valid attribute, and we have an
      error.</li>
    </ol>
  </li>
  <li>If the method is annotated with @ManagedOperation:
    <ol>
      <li>The id is the method name.</li>
    </ol>
  </li>
</ol>
These rules are applied unless the ManagedAttribute or ManagedOperation
annotation has a non-default id attribute, in which<br>
case the id from the annotation is used.<br>


<h3>4.2. I18N support</h3>
Gmbal supports I18N by supplying a ResourceBundle to the
ManagedObjectManager.  If this option is used, all values of<br>
@Description annotations must be resource bundle keys.  The appropriate
ResourceBundle must then be associated with<br>
the ManagedObjectManager when the ManagedObjectManager is created.<br>


<h3>4.3. OpenType mapping<br>
</h3>
Gmbal mostly follows the OpenType mapping rules for MXBeans (see the <a
href="http://java.sun.com/javase/6/docs/api/javax/management/MXBean.html#mapping-rules">Type
Mapping Rules</a>), but of course<br>
MXBeans are only available on JDK 6 and later, and gmbal supports JDK 5. There
are a few differences:<br>

<ol>
  <li>Gmbal supports all Collection, Iterator, Iterable, and Enumeration types
    where MXBeans support List, Set, and SortedSet.</li>
  <li>Gmbal also maps Dictionary as well as Map to TabularType.</li>
  <li>Gmbal maps all @ManagedObject types to ObjectName (in MXBeans, this is
    any MXBean interface.</li>
  <li>Gmbal only maps other types to CompositeData if the type has an
    @ManagedData annotation.  If not, gmbal maps the type to a String using
    its toString() method.</li>
  <li>While MXBeans handle SortedSet and SortedMap specially, gmbal does
  not.</li>
  <li>Gmbal does not support reconstructing a Java type from CompositeData.
    Gmbal could be extended in this area if necessary.</li>
  <li>Gmbal will provide more support for converting generic types into generic
    MBean types, which can be instantiated into specific MBeans based on the
    actual type parameters supplied to an instance of the generic type.</li>
</ol>
Gmbal does not currently provide support for setting attributes with
CompositeData values (but this would be easy to add, following<br>
the rules used for MXBeans).<br>


<h3>4.4. Metadata support<br>
</h3>
Gmbal fully supports extensible metadata on MBeans by using the JMX ModelMBean
Descriptor, which is available on JDK 5.<br>
JDK 6 has applied Descriptor support to ALL MBean metadata, but gmbal must
continue to support JDK 5 for now.<br>
Gmbal supports the @DescriptorKey and @DescriptorFields annotations defined in
JSR 255 for associating metadata<br>
with MBeans.  Gmbal also defines an annotation @MBeanType (which itself uses
the meta-annotation @DescriptorKey)<br>
in order to support the metadata needed by AMX.<br>


<h3>4.5. AMX support on MBeans</h3>
Gmbal will be fully compliant with all requirements and recommendations of the
<a
href="https://glassfish.dev.java.net/nonav/v3/admin/planning/V3Changes/V3_AMX_SPI.html">GlassFish
v3 AMX SPI</a>.<br>
This includes:<br>

<ul>
  <li>Creating ObjectNames according to the parent/child hierarchy.  Gmbal
    will never put anything in an ObjectName that is not part of the AMX
    specification.</li>
  <li>Supporting the MBeanInfo Descriptor.  This is handled in gmbal through
    the @MBeanType annotation.</li>
  <li>All MBeans created using gmbal will include all of the attributes defined
    in section 4 of the AMX SPI spec.</li>
  <li>Gmbal will only use Open data types.</li>
  <li>Gmbal will support all of the behavior requirements of section 5 of the
    AMX SPI spec.  This include support for AttributeChangeNotifdication.<br>
  </li>
</ul>

<h3>4.6. Using Gmbal<br>
</h3>
The basic usage of Gmbal is as follows:<br>

<ol>
  <li>Add annotations to existing application objects (here application means
    anything you want to manage, part of GFv3 or not) to expose attributes and
    operations.</li>
  <li>In some cases you may need to expose some data by defining new methods. 
    Currently all gmbal visible annotations must be public, but I may relax
    that (at the cost of requiring an access check permission for
  reflection).</li>
  <li>In the initialization of a module, create an appropriate
    ManagedObjectManager (call it mom).  This requires thinking about where in
    the federated hierarchy the root of the ManagedObjectManager should live. 
    In some cases, this may be different depending on the environment in which
    the instrumented code runs.</li>
  <li>Whenever an Object is created that requires a management interface,
    register that object with the mom.</li>
  <li>Whenever an Object is no longer needed, unregister that object with the
    mom.</li>
  <li>Whenever the module lifecycle ends, call mom.close() to clean up the root
    object and any other remaining registered objects.</li>
</ol>

<h3>4.7. Handling Polymorphism</h3>
There are cases where an attribute has a type defined by a base class or
interface, but the actual implementation can be<br>
one of several different classes.  For example, the ORB has a TaggedComponent
interface, representing part of the data in a<br>
remote reference, and there are several concrete subclasses of TaggedComponent
that are used.  This is not a problem<br>
for @ManagedObject classes, since they are reference by ObjectNames, and an
ObjectName can reference any type of <br>
MBean.  But this does not work for @ManagedData, because @ManagedData is
mapped to a CompositeData type, and<br>
CompositeData does not support polymorphism.<br>
<br>
Gmbal supports a limit form of polymorphism to handle this case using the
@IncludeSubclass annotation.  @IncludeSubclass<br>
gives the subclasses of a @ManagedData type which themselves can contribute
attributes to the CompositeData for the<br>
parent class.  Gmbal generates a CompositeData type that contains the union of
all fields in all of the subclasses. At runtime,<br>
only those attributes actually present in a particular instance of the
@ManagedData class are present in the <br>
CompositeData for the instance.  In this way, gmbal supports a limit form of
polymorphism under a closed-world<br>
assumption.<br>


<h3><a name="L2005" id="L2005"></a>4.8. Issues with generic types</h3>

<p>This is best explained with an example.  Suppose we have interfaces defined
as follows:<br>
</p>
<pre>@ManagedData<br>public interface ExampleData&lt;S,T&gt; {<br>    S        getInfo() ;<br><br>    List&lt;T&gt; getData() ;<br>}<br><br>public interface Example&lt;S,T&gt; {<br>    @ManagedAttribute<br>    ExampleData&lt;S,T&gt; getInfo() ;<br>}<br><br>@ManagedObject<br>public interface MyBean extends Example&lt;Date,List&lt;String&gt;&gt; {<br>}<br></pre>
What sort of MBean should we create for MyBean?  If we just use reflection on
MyBean, we find an attribute info that<br>
returns an ExampleData&lt;S,T&gt;, which would turn into a CompositeData with
two attributes:<br>

<ul>
  <li>id=info, type=Object (since type is type variable S)</li>
  <li>id=data, type=List&lt;Object&gt; (since type is List&lt;type
  variable&gt;</li>
</ul>
But we actually have a lot more information than this: if we "evaluate" the
types, we should see attributes on the CompositeData like:<br>

<ul>
  <li>id=info, type=Date</li>
  <li>id=data, type=List&lt;List&lt;String&gt;&gt;</li>
</ul>
So instead of erasing the types, we evaluate the type variable by replacing the
type variables with the types used<br>
to instantiate them.  Another way of looking at this is that annotating a
generic interface or class with @ManagedData or<br>
@ManagedObject is basically creating a template for creating the actual
CompositeData or Open MBean.<br>


<h3>4.9. Issues with recursive types</h3>
CompositeData cannot be defined directly from class definitions that have
recursive types.  Here is an example of the problem:<br>

<pre>@ManagedData<br>public interface A {<br>    @ManagedAttribute<br>    B getB() ;<br>}<br><br>@ManagedData<br>public interface B {<br>    @ManagedAttribute<br>    A getA() ;<br>}<br></pre>
The problem here is that we need to construct an instance of CompositeType to
represent the OpenType to which A and B are <br>
mapped.  But CompositeData is immutable, so in order to construct the
CompositeType for A, we need the CompositeType of<br>
B, which can't be constructed without using the CompositeType of A.  So a
direct mapping fails here, and gmbal will detect<br>
this problem and throw an exception.<br>
<br>
The way to work around the problem is to add a level of indirection so that one
of the classes refers to the other indirectly.<br>
For example, support A has a convenient String name attribute we can use (which
is a key for instances of A).  <br>
Then the above can be expressed as:<br>

<pre>@ManagedData <br>public interface A {<br>    @ManagedAttribute<br>    String getName() ;<br><br>    @ManagedAttribute<br>    B getB() ;<br>}<br><br>@ManagedData<br>public interface B {<br>    @ManagedAttribute( id="b" ) <br>    String getARef() ; // returns getA().getName()<br><br>    A getA() ;<br>}<br></pre>
In this way the relationship between A and B can still be represented in the
management API without needing<br>
recursive references between different data types that are represented with
CompositeData.<br>
<br>
Note that it is possible to automate this to some extent, but I currently have
no plans to extend gmbal to<br>
automatically handle this problem.<br>


<h2>5. Dependencies</h2>
The only dependency that gmbal has is JDK 5.  It does not require anything
from JMX<br>
that is not in JDK 5.  It also has no dependencies on GlassFish v3  or
CORBA.<br>


<h2>6. Testing</h2>
All tests for gmbal are written in Java using JUnit, and reside in the test
directory in the project.<br>


<h2>7. Project Details</h2>
The gmbal project is publicly available in a mercurial workspace at <a
href="https://kenai.com/hg/gmbal%7Emaster">https://kenai.com/hg/gmbal~master.</a><br>
Note that gmbal will NOT be built as part of the  GFv3 build.  This is
necessary because gmbal is also used outside of GFv3, and we need to avoid
circular build dependencies (e.g. GFv3 dependsOn CORBA dependsOn gmbal, which
creates a build loop if GFv3 also contains gmbal).<br>
<br>
gmbal uses the following packages:<br>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Package
        Name</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">OSGi 
        Bundle</span><br>
      </td>
      <td style="vertical-align: top;"><span
        style="font-weight: bold;">Purpose</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal<br>
      </td>
      <td style="vertical-align: top;">gmbal-api<br>
      </td>
      <td style="vertical-align: top;">all public interfaces<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal.util<br>
      </td>
      <td style="vertical-align: top;">gmbal-api<br>
      </td>
      <td style="vertical-align: top;">contains code needed to support the
        API-Impl split (reflective construction of the implementation)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal.generic<br>
      </td>
      <td style="vertical-align: top;">gmbal-impl<br>
      </td>
      <td style="vertical-align: top;">General-purpose code for debugging, plus
        simple function programming support<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal.impl<br>
      </td>
      <td style="vertical-align: top;">gmbal-impl<br>
      </td>
      <td style="vertical-align: top;">The full implementation.  <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
The resulting OSGi bundles are currently (version 2.0.0-b001) sized at:<br>
<br>


<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">gmbal-api<br>
      </td>
      <td style="vertical-align: top;">12751 bytes<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">gmbal-impl<br>
      </td>
      <td style="vertical-align: top;">123049 bytes<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
</body>
</html>
