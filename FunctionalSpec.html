<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<!-- 
    Document   : FunctionalSpec
    Created on : Nov 17, 2008, 4:25:47 PM
    Author     : ken
-->
  <title>JMXA Functional Spec</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<body>
<h1>GlassFish MBean Annotation Library (gmbal)</h1>
<h1>Functional Specification</h1>
<br>
by Ken Cavanaugh<br>
Spec version .20<br>
12/05/08<br>
<br>
<h2>Introduction</h2>
The GlassFish MBean Annotation Library (gmbal) is a runtime annotation
processor that creates Open MBeans.<br>
This is useful for creating a management API for existing code with
minimal effort.&nbsp; It is intended to be applied<br>
to existing modules (which may be OSGi bundles in GlassFish v3, or any
other packaging model including <br>
standard jar files), but could be used anywhere that it is desired to
combine the definition of the<br>
management API with the module API and implementation.<br>
<br>
There are really two parts to creating a management API for a module:
instrumenting the module implementation,<br>
and providing a client interface that may be accessed remotely.&nbsp;
This is what AMX has done in GlassFish, and<br>
gmbal will follow the same model.<br>
<br>
The details on the client model still need to be worked out, but
basically gmbal will generate Java source code <br>
from annotated classes to provides client-side proxies for remote
access to the gmbal-generated MBeans. <br>
The proxies will take care of mapping MBean ObjectNamess to a
type-specific interface that extends the AMX interface,<br>
mapping OpenTypes to application-domain types (e.g. map CompositeData
to a Java class containing getters<br>
for its various data elements), and any other details that make the
client side API simple to use.<br>
<br>
The source code generation will be in two pieces:<br>
<ol>
  <li>A set of interfaces for MBean and OpenType definitions that can
have as extensive JavaDocs written as needed. The description
information will be filled in as a default and starting point for the
JavaDocs. This should be generated once and maintained separately&nbsp;
to preserve the JavaDocs, rather than generated for each build.<br>
  </li>
  <li>A set of implementations of the interfaces that is generated for
each build. This will detect inconsistencies between the interfaces and
implementations.</li>
</ol>
The source code generation will be driven from the meta data produced
by analyzing the classes, using the same code. The tool itself will be
packaged separately from the main implementation, since it is only
needed at build time.<br>
<br>
<h3>Alignment with related projects</h3>
JMX is also defining similar annotations in JSR 255 for JDK 7.&nbsp; I
am aligning gmbal with the JMX annotations as much as I think is
reasonable, given the different goals of the project.&nbsp; <br>
<br>
The similarities include:<br>
<ul>
  <li>@ManagedAttribute is the same, except that gmbal allows
overriding the id.</li>
  <li>@ManagedOperation is the same, except that gmbal allows
overriding the id.</li>
  <li>@DescriptorKey is the same.</li>
  <li>@DescriptorFields is the same.</li>
  <li>@Description is similar, but gmbal only has a value() attribute,
while JSR 255 has key and bundleBaseName. Gmbal takes the approach that
I18N support is handled by using keys on the annotation only, then
providing a separate resource bundle which can be registered with the
ManagedObjectManager (see the discussion <a
 href="#MBeanServer_and_ResourceBundle">below</a>).<br>
  </li>
</ul>
Differences:<br>
<ul>
  <li>The packaging is necessarily different: org.glassfish.gmbal for
gmbal, javax.management for JSR 255.</li>
  <li>Gmbal uses @ManagedObject instead of @MBean or @MXBean (because I
really don't want that level of confusion).</li>
  <li>Gmbal only support attribute change notifications (so far), so
the @NotificationInfo does not exist in Gmbal.</li>
  <li>Gmbal has an @ManagedData annotation to define the mapping of
data types into CompositeData, while JSR 255 follows MXBeans and simply
assumes that all methods that follow the JavaBeans patterns define
read-only attributes.</li>
  <li>Gmbal supports an MBeanType annotation, but this is really just
an extension to the @Descriptor mechanism borrowed from JMX
ModelMBeans.&nbsp; The MBeanType annotation is provided to support
AMX-specific metadata.</li>
  <li>Gmbal includes @ParameterNames to provide reasonable names for
the arguments on MBean operations.&nbsp; JSR 255 does not currently
have such a mechanism, because JDK 7 will have an extension to Java
reflection that captures the argument names on methods.</li>
  <li>Gmbal includes @ObjectNameKey to make it easy to define the value
of the "name" field in the ObjectName. This makes registration of
object as MBeans slightly simpler.</li>
  <li>Gmbal includes @IncludeSubclass, which allows limited (and
closed) polymorphism for CompositeData.&nbsp; This partially solves the
problem of mapping a group of types sharing type Base that appear as
(for example) attributes with type List&lt;Base&gt;.</li>
  <li>Gmbal includes @InheritedAttribute(s) to allow using methods
inherited from super classes or super interfaces that cannot be
annotated as attribute and operations.</li>
  <li>Gmbal is more limited currently in mapping OpenType -&gt; Java
type than JMX is, as this does not seem to be a feature that we need.<br>
  </li>
</ul>
Note that there are two complimentary ways to define MBeans: MXBeans
and annotations.&nbsp; MXBeans are somewhat more convenient to use in
cases where EVERY method in a class or interface is part of the
management interface, whereas annotations are more convenient for
adding a management interface to existing code.<br>
<br>
AMX in GlassFish v3 is being generalized to define exactly what an
MBean must do to be manageable in the GlassFish v3 admin tools (see
Lloyd's <a
 href="https://glassfish.dev.java.net/nonav/v3/admin/planning/V3Changes/V3_AMX_SPI.html">GlassFish
V3 AMX SPI</a> specification). Gmbal will follow all mandatory and most
of the optional requirements of this specification so that any module
that uses gmbal to define MBeans will automatically participate in the
GFv3 admin console and CLI when run in a GFv3 container.&nbsp; However,
this will not prevent the use of gmbal in these same modules as a
standalone MBean definition library.<br>
<br>
This last point needs a little more explanation.&nbsp; The main
interface that matters for running in or out of a GFv3 container is
ManagedObjectManagerFactory.createXXX (XXX is either Standalone or
Federated). The createStandalone method is needed for running outside
of GFv3, and takes the domain name as an argument. createFedederated
must be called inside of GFv3, and this require the ObjectName of the
ManagedObjectManager root MBean's parent.&nbsp; Calling the appropriate
method is probably best handled in many cases by having a OSGi bundle
for a module that is responsible for integrating the module into
GFv3.&nbsp; For example, the ORB will need such a module to handle
registration of all of the GFv3-specific interceptors and other
initialization when the GFv3 ORB instance is created.<br>
<br>
<h3>Similar projects</h3>
I have already discussed JSR 255 in the previous section, but there are
other projects that also define MBeans using annotations.<br>
<br>
The Spring project also defines a set of annotations to use for
creating MBeans.&nbsp; Eamonn McManus has pointed<br>
to this as one of the starting points for JSR 255 in a blog <a
 href="http://weblogs.java.net/blog/emcmanus/archive/2007/08/defining_mbeans.html">post</a>
from August 2007.&nbsp; JSR 255 and Spring share the<br>
@ManagedAttribute and @ManagedOperation annotations, but the Spring
annotations include a description fields,<br>
whereas JSR 255 has moved the description into a separate annotation
(as I have in gmbal as well).<br>
<br>
The WebObject project from INRIA in France has created the <a
 href="http://spoon.gforge.inria.fr/SpoonJMX/Main">SpoonJMX</a>
project, which also allows the use of annotations<br>
to define MBeans. SpoonJMX uses @ManagedResource to define an MBean
class.&nbsp; It uses @ManagedAttribute and @ManagedOperation<br>
as in the other systems.&nbsp; SpoonJMX defines the @ObjectNameKey
annotation, which I have adopted for use in<br>
gmbal as well.&nbsp; SpoonJMX also defines more attributes on the
annotations than either gmbal or JSR 255.<br>
<br>
<h2>The Management Data Model</h2>
JMXA supports a simple hierarchical model of management data as defined
in JSR 77 and AMX.<br>
<img style="width: 730px; height: 507px;" alt="JMXA Class Diagram"
 src="JMXA.png"><br>
The components of the data model are as follows:<br>
<ul>
  <li>A ManagedObjectManager acts as a container for all state related
to a particular usage of gmbal. This includes:</li>
  <ul>
    <li>A domain to use for all ObjectNames created in this
ManagedObjectManager</li>
    <li>A rootParentName, which is the ObjectName of the parent of the
ManagedObjectManager</li>
    <li>A root object, which represents the top of the tree of MBean
managed by the ManagedObjectManager<br>
    </li>
  </ul>
  <li>From a POJO with annotations, an MBeanImpl is constructed.&nbsp;
An MBeanImpl has a number of objects associated with it:</li>
  <ul>
    <li>0 or more Attributes, which may be getters or setters or both</li>
    <li>0 or more Operations, which may be invoked</li>
    <li>Metadata, represented by ModelMBeanInfoSupport (so that
metadata Descriptors are available on JDK 5 as well as JDK 6)</li>
    <li>A single parent MBeanImpl, which may be null (this is one end
of the contains relation)</li>
    <li>0 or more child MBeanImpls (this is the other end of the
contains relation)</li>
    <li>Following JSR 77, a type and a name String, which together with
the ObjectName of the parent are used to form the ObjectName of the
MBeanImpl<br>
    </li>
  </ul>
  <li>Attributes and Operations have ids</li>
</ul>
Note that all values consumed or produced by Attributes and Operations
are instances of OpenTypes.<br>
<br>
This diagram is a simplification of the actual implementation of
gmbal.&nbsp; In particular, <br>
the metadata, attributes, and operations are maintained in a
MBeanSkeleton class, which is<br>
shared by all MBeanImpls for instances of the same class.&nbsp; The
TypeConverter that handles<br>
conversion between Java types and the corresponding OpenType is also
not included here.<br>
<br>
<h2>Interfaces</h2>
Javadocs are <a href="dist/javadoc/index.html">available</a> as part
of the gmbal project.&nbsp; <br>
<br>
There are basically 3 elements to the gmbal API:<br>
<ol>
  <li>class ManagedObjectManagerFactory, which provides factory methods
for creating instance of the ManagedObjectManager interface.</li>
  <li>interface ManagedObjectManager, which provides
register/deregister methods (and a number of other capabilities).</li>
  <li>A number of annotations.<br>
  </li>
</ol>
<br>
Here is a summary of the annotations:<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">Annotation
Class<br>
      </td>
      <td style="vertical-align: top; font-weight: bold; width: 25%;">Annotation
Fields<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Applicable
Element Type<br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Relation
to JSR 255</span><br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">Purpose<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedObject<br>
      </td>
      <td style="vertical-align: top;">none<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">255 uses @MXBean<br>
      </td>
      <td style="vertical-align: top;">Defines a class whose instances
are processed into MBeans.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedData<br>
      </td>
      <td style="vertical-align: top;">String name (defaults to class
name)<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">MXBeans assume all methods are
in CompositeData<br>
      </td>
      <td style="vertical-align: top;">Defines a class whose instances
are process into Open data for Open Mbeans.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedAttribute<br>
      </td>
      <td style="vertical-align: top;">String id (defaults to value
from Method name)<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">Same<br>
      </td>
      <td style="vertical-align: top;">Defines a method that represents
an attribute either in ManagedData or ManagedObject<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ManagedOperation<br>
      </td>
      <td style="vertical-align: top;">String id (defaults to value
from Method name)<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">Same<br>
      </td>
      <td style="vertical-align: top;">Defines a method that represents
an operation in ManagedObject <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@Description<br>
      </td>
      <td style="vertical-align: top;">String value<br>
      </td>
      <td style="vertical-align: top;">Class, Interface, or Method<br>
      </td>
      <td style="vertical-align: top;">Same (but JSR 255 includes I18N)<br>
      </td>
      <td style="vertical-align: top;">Defines the descriptive text
associated with a Class, Interface, or Method<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@IncludeSubclass<br>
      </td>
      <td style="vertical-align: top;">Class[] value<br>
      </td>
      <td style="vertical-align: top;">Class or Interface for
ManagedData<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Lists subclasses of the
annotated class that should also be scanned for annotations which are
included only on instances of the appropriate type<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ObjectNameKey<br>
      </td>
      <td style="vertical-align: top;">none<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Defines a method (must be a
getter) whose result is the name of the MBean for an instance of the
class<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@ParameterNames<br>
      </td>
      <td style="vertical-align: top;">String[] value (defaults to "")
(if present, must have same length as number of arguments in the
annotated method)<br>
      </td>
      <td style="vertical-align: top;">Method<br>
      </td>
      <td style="vertical-align: top;">N/A (JSR 255 will take this
information from reflection, which will make arg names available in JDK
7)<br>
      </td>
      <td style="vertical-align: top;">Defines the method names to be
used on an MBean operation<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@InheritedAttribute<br>
      </td>
      <td style="vertical-align: top;">
      <ul>
        <li>String description</li>
        <li>String id (default "" which means take from method name)</li>
        <li>String methodName (default "" which means use id)</li>
        <li>one of methodName or id must NOT be ""<br>
        </li>
      </ul>
      <br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Defines a method inherited from
a class that cannot be annotated as an attribute<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@InheritedAttributes<br>
      </td>
      <td style="vertical-align: top;">InheritedAttribute[] value<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">N/A<br>
      </td>
      <td style="vertical-align: top;">Allows including multiple
inherited attributes<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@MBeanType<br>
      </td>
      <td style="vertical-align: top;">
      <ul>
        <li>String pathPart (the type to use in an ObjectName or in an
admin CLI path expression:&nbsp; defaults to class name, but see
also&nbsp; <a href="#addTypePrefix">addTypePrefix</a>)</li>
        <li>boolean isLeaf (true if this MBean can not contain other
MBeans)</li>
        <li>boolean isSingleton (true&nbsp; if only one MBean of this
type is allowed as a child of&nbsp; another MBean)</li>
        <li>&nbsp;boolean isMBeanInfoInvariant (true if the MBeanInfo
can never change)</li>
        <li>String pathPart (value to use in AMX CLI commands: defaults
to type)</li>
        <li>String group() (value is the group for this mbean, defaults
to "other")</li>
        <li>String[] subTypes() (value is the list of allowable types
for children of this bean)<br>
        </li>
      </ul>
&nbsp;(This is just an application of @DescriptionKey, with a little
special support in the gmbal implementation)<br>
      </td>
      <td style="vertical-align: top;">Class or Interface<br>
      </td>
      <td style="vertical-align: top;">N/A (but JMX supports
descriptors; see below)<br>
      </td>
      <td style="vertical-align: top;">Adds GFv3 and AMX specific
metadata to be defined for MBeans<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@DescriptionKey<br>
      </td>
      <td style="vertical-align: top;">String value<br>
      </td>
      <td style="vertical-align: top;">Annotation method<br>
      </td>
      <td style="vertical-align: top;">same as JSR 255<br>
      </td>
      <td style="vertical-align: top;">Define metadata that can be
added to any MBean<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">@DescriptionField<br>
      </td>
      <td style="vertical-align: top;">String value (must be name=value)<br>
      </td>
      <td style="vertical-align: top;">Class, Interface, or Method<br>
      </td>
      <td style="vertical-align: top;">same as JSR 255<br>
      </td>
      <td style="vertical-align: top;">Define metadata directly on MBean<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h3>The ManagedObjectManagerFactory</h3>
The ManagedObjectManagerFactory is primarily used to create
ManagedObjectManagers.&nbsp; It is the only concrete class in the gmbal
API.<br>
<br>
<h4>getMethod</h4>
This is a simple wrapper around Class.getDeclaredMethod that converts
the checked exceptions from getDeclaredMethod into unchecked
exceptions.&nbsp; It is intended for use with the <a
 href="#addAnnotation">addAnnotation</a> method.<br>
See also the <a href="#What_if_you_cannot_add_an_annotation">discussion</a>
about adding annotations.<br>
<br>
<h4>create</h4>
There are two versions of create: create( String ) and create(
ObjectName ).&nbsp; create( String ) is used to create a standalone
hierarchy: the String is the domain to use for all ObjectNames created
from the resulting ManagedObjectManager.&nbsp; In this versioSn, the
root has no parent.<br>
<br>
create( ObjectName ) is used to create a hierarchy of MBeans that are
rooted under a parent MBean that is not managed by the created instance
of ManagedObjectManager.&nbsp; In this case, the parent of the
ManagedObjectManager is identified by the object name (called the
rootParentName) that is passed to the create call.&nbsp; Note that the
root parent MBean MUST be managed by the same MBeanServer as the
ManagedObjectManager.<br>
<br>
<h3>The ManagedObjectManager</h3>
The ManagedObjectManager is the main API for gmbal.&nbsp; It contains a
tree of MBeans with a single root,<br>
which may optionally be federated into a large MBean hierarchy.<br>
<br>
The most important methods are createRoot, register, and
unregister.&nbsp; Any application of gmbal must use these
methods.&nbsp;
<br>
<br>
<h4>createRoot</h4>
There are several methods to create a root in the
ManagedObjectManager.&nbsp; createRoot() creates a root that simply
acts as an AMX container.&nbsp; Its type and name are both set to
GMBALROOT.<br>
<br>
createRoot( Object ) and createRoot( Object, String ) both use the
given object as the root, and just as in the register methods, these
methods create an MBean from the Object using the annotations on its
class. The createRoot( Object ) method will derive the name from the
object itself by calling the @ObjectNameKey method from the
class.&nbsp; If no such method is available, the name is set to the
type value.&nbsp; The second method allows the name to specified
explicitly.&nbsp; This can be useful in case where either
@ObjectNameKey is not used, or there are multiple ManagedObjectManager
instances with the same root type that share the same parent.&nbsp; In
this case, it is essential that each root have a distinct name.last<br>
<br>
createRoot may only be called when the ManagedObjectManager does not
already contain a root. This is true immediately after a
ManagedObjectManagerFactory.create call, or after unregistering the
root.<br>
<br>
<h4>getRoot</h4>
getRoot returns the current root of the ManagedObjectManager.&nbsp; If
no root is available, getRoot throws an IllegalStateException.<br>
<br>
<h4>register and registerAtRoot</h4>
There are two forms of register: register( Object parent, Object obj )
and register( Object parent, Object obj, String name ).&nbsp; The first
form obtains the name from obj (either via @ObjectNameKey, or by
default using the type), the second allows explicit
specification.&nbsp; The returned result is an instance of
NotificationEmitter that may be used to register a NoticationListener
to listen for attribute change notifications on that particular
MBean.&nbsp; <br>
<br>
There are also two forms of registerAtRoot: registerAtRoot( Object obj
) and registerAtRoot( Object obj, String name).&nbsp; These methods are
exactly equivalent to mom.register( mom.getRoot(), obj ) and
mom.register( mom.getRoot(), obj, name ).<br>
<br>
<h4>unregister</h4>
unregister( Object ) unregisters an object that was previously
registered.&nbsp; It also deletes any children of the object in
depth-first order.&nbsp; Unregister removes the generated MBean from
the ManagedObjectManager and also unregisters the MBean from the
ManagedObjectManager's MBeanServer.<br>
<br>
<h4>getObject/getObjectName</h4>
The register methods return a NotificationEmitter which can be used to
register a NotificationListener to listen for attribute change
events.&nbsp; But sometimes access to the ObjectName is needed.&nbsp;
getObjectName returns the ObjectName that was created for an object
that was passed to the register method.&nbsp; getObject is used to
handle the opposite case: going from the ObjectName to the registered
Object.&nbsp; Note that in both case the registered Object is the
implementation object passed to a register method, NOT the internally
created dynamic MBean (which is not directly provided).<br>
<br>
<h4><a name="addTypePrefix"></a>addTypePrefix</h4>
A type prefix is simply a prefix of a fully qualified Java class name.
By default, the MBean ObjectName type field is set to the full
qualified class name of the implementation class, stripped of the
longest type prefix of the class name.&nbsp; For example, in CORBA the
type prefixes are set to:<br>
<br>
<div style="margin-left: 40px;">com.sun.corba.se<br>
com.sun.corba.se.spi<br>
com.sun.corba.se.spi.orbutil<br>
com.sun.corba.se.impl<br>
com.sun.corba.se.impl.orbutil<br>
<br>
</div>
This helps keep the ObjectNames to a reasonable length.&nbsp;
Applications of gmbal are also free to specifiy the exact type name to
use through an annotation.<br>
<br>
<h4><a name="MBeanServer_and_ResourceBundle"></a>MBeanServer and
ResourceBundle</h4>
Accessors (getter and setter) are provided for the MBeanServer and the
ResourceBundle.<br>
<br>
The MBeanServer is used for all register and unregister operations in
the ManagedObjectManager instance. It defaults to the<br>
platform MBeanServer.<br>
<br>
The ResourceBundle is used to internationalize all descriptions.&nbsp;
If set, the description value is used as a key in the resource bundle,<br>
otherwise the description value is taken as the actual description.<br>
<h4><a name="addAnnotation"></a>addAnnotation</h4>
The best way to explain this method is to start wth an example.&nbsp;
CORBA defines a class org.omg.PortableServer.Servant.&nbsp; <br>
The definition of Servant is a standard, and so I cannot add
annotations to the source code for Servant.&nbsp; Gmbal is flexible<br>
enough that we can put the annotation almost anywhere, so what are the
possible subclasses of Servant?<br>
Mostly one subclass is used in GlassFish for dynamic RMI-IIOP:
ReflectiveTie, but others are possible, including<br>
Ties generated by the idlj compiler.&nbsp; We also cannot add
non-standard annotations to standard-compliant code generated<br>
by a code generator.<br>
<br>
This becomes an issue when adding annotations to things like the ORB's
POA, which has a method:<br>
<pre>@ManagedData<br>Servant get_servant() { ... }<br></pre>
that I would like to use as an attribute.&nbsp; How should gmbal
represent Servant in this case?&nbsp; I may want to represent<br>
the Servant as ManagedData, using one or more methods (such as byte[]
_object_id()) on the Servant as attributes,<br>
but there is no place that I can put an annotation for this.<br>
<br>
The solution I have adopted in gmbal is to allow annotations to be
added on "dummy" classes, and then use <br>
ManagedObjectManager.addAnnotation to add the annotation to the
appropriate type.&nbsp; For example, the above example<br>
can be handled by:<br>
<br>
<pre>@ManagedData<br>@InheritedAttributes( {<br>    @InheritedAttribute( methodName="_object_id", id="objectId",<br>	description="The Object Id for this Servant" ),<br>    ... // serveral other methods<br>} )<br>public interface DummyServant {}<br><br>mom.addAnnotation( Servant.class, DummyServant.class.getAnnotation( ManagedObject.class ) ) ;<br>mom.addAnnotation( Servant.class, DummyServant.class.getAnnotation( InheritedAttributes.class ) ) ;<br></pre>
This behaves exactly as if the annotations on DummyServant were on
Servant, allowing the appropriate <br>
annotation processing to take place.<br>
<br>
InheritedAttribute can also be used when it is desired to use a method
inherited from a super class as<br>
an attribute or operation.&nbsp; This is useful in the case where the
superclass is a class that for whatever<br>
reason cannot be modified with an annotation.<br>
<h4>Debugging support</h4>
Gmbal is a fairly complex system, and it is possible to apply it in
ways that lead to incorrect results.<br>
To help with this, I have defined several features that can be useful
for debugging:<br>
<ul>
  <li>setRegistrationDebugLevel( RegistrationDebugLevel level ).&nbsp;
Here the level can be NONE, NORMAL, or FINE.&nbsp; When enabled, this
method causes detailed tracing (more detailed with FINE) of the
operations involved in registering an MBean.</li>
  <li>setRuntimeDebugLevel( boolean flag ).&nbsp; If this is enabled,
the operations involved in getting or setting attributes or calling an
operation on an MBean are traced.</li>
  <li>String dumpSkeleton( Object obj ).&nbsp; If obj is an object that
has been registered with the ManagedObjectManaged, this returns a
String dump of the MBeanSkeleton object, which provides detailed
information about the exact attributes and operations supported by the
MBean.</li>
</ul>
These operations can be used to get useful information about the
operation of gmbal.&nbsp; The setXXXDebugLevel methods currently dump<br>
information to System.out, but the code has a flag that can be set to
dump information to a Logger.&nbsp; The Logger may become the <br>
default dump mechanism in the future.<br>
<h2>Further notes on the API<br>
</h2>
There are a number of details about how the APIs work that require
further discussion.<br>
<br>
<h3>Processing of method names for IDs</h3>
The following rules are applied to generate attribute and operation IDs
from method names:<br>
<br>
<ol>
  <li>If the method is annotated with @ManagedAttribute:<br>
  </li>
  <ol>
    <li>If the method is a getter (that is, it has no arguments and a
non-void result):</li>
    <ol>
      <li>If the method name starts with "get", remove "get" and make
the next letter lowercase.</li>
      <li>If the return type is boolean, and the method starts with
"is", remove "is" and make the next letter lowercase.</li>
      <li>Otherwise the method name is the id.<br>
      </li>
    </ol>
    <li>If the method is a setter (that, has one argument and a void
result):</li>
    <ol>
      <li>If the method name starts with "set", remove "set" and make
the next letter lowercase.</li>
      <li>Otherwise the method name is the id.</li>
    </ol>
    <li>Otherwise the method is not a valid attribute, and we have an
error.</li>
  </ol>
  <li>If the method is annotated with @ManagedOperation:</li>
  <ol>
    <li>The id is the method name.</li>
  </ol>
</ol>
These rules are applied unless the ManagedAttribute or ManagedOperation
annotation has a non-default id attribute, in which<br>
case the id from the annotation is used.<br>
<h3>I18N support</h3>
Gmbal supports I18N by supplying a ResourceBundle to the
ManagedObjectManager.&nbsp; If this option is used, all values of<br>
@Description annotations must be resource bundle keys.&nbsp; The
appropriate ResourceBundle must then be associated with<br>
the ManagedObjectManager when the ManagedObjectManager is created.<br>
<br>
<h3>OpenType mapping<br>
</h3>
Gmbal mostly follows the OpenType mapping rules for MXBeans (see the <a
 href="http://java.sun.com/javase/6/docs/api/javax/management/MXBean.html#mapping-rules">Type
Mapping Rules</a>), but of course<br>
MXBeans are only available on JDK 6 and later, and gmbal supports JDK
5. There are a few differences:<br>
<ol>
  <li>Gmbal supports all Collection, Iterator, Iterable, and
Enumeration types where MXBeans support List, Set, and SortedSet.</li>
  <li>Gmbal also maps Dictionary as well as Map to TabularType.</li>
  <li>Gmbal maps all @ManagedObject types to ObjectName (in MXBeans,
this is any MXBean interface.</li>
  <li>Gmbal only maps other types to CompositeData if the type has an
@ManagedData annotation.&nbsp; If not, gmbal maps the type to a String
using its toString() method.</li>
  <li>While MXBeans handle SortedSet and SortedMap specially, gmbal
does not.</li>
  <li>Gmbal does not support reconstructing a Java type from
CompositeData. Gmbal could be extended in this area if necessary.</li>
  <li>Gmbal will provide more support for converting generic types into
generic MBean types, which can be instantiated into specific MBeans
based on the actual type parameters supplied to an instance of the
generic type.</li>
</ol>
Gmbal does not currently provide support for setting attributes with
CompositeData values (but this would be easy to add, following<br>
the rules used for MXBeans).<br>
<br>
<h3>Metadata support<br>
</h3>
Gmbal fully supports extensible metadata on MBeans by using the JMX
ModelMBean Descriptor, which is available on JDK 5.<br>
JDK 6 has applied Descriptor support to ALL MBean metadata, but gmbal
must continue to support JDK 5 for now.<br>
Gmbal supports the @DescriptorKey and @DescriptorFields annotations
defined in JSR 255 for associating metadata<br>
with MBeans.&nbsp; Gmbal also defines an annotation @MBeanType (which
itself uses the meta-annotation @DescriptorKey)<br>
in order to support the metadata needed by AMX.<br>
<h3>AMX support on MBeans</h3>
Gmbal will be fully compliant with all requirements and recommendations
of the <a
 href="https://glassfish.dev.java.net/nonav/v3/admin/planning/V3Changes/V3_AMX_SPI.html">GlassFish
v3 AMX SPI</a>.<br>
This includes:<br>
<ul>
  <li>Creating ObjectNames according to the parent/child
hierarchy.&nbsp; Gmbal will never put anything in an ObjectName that is
not part of the AMX specification.</li>
  <li>Supporting the MBeanInfo Descriptor.&nbsp; This is handled in
gmbal through the @MBeanType annotation.</li>
  <li>All MBeans created using gmbal will include all of the attributes
defined in section 4 of the AMX SPI spec.</li>
  <li>Gmbal will only use Open data types.</li>
  <li>Gmbal will suport all of the behavior requirements of section 5
of the AMX SPI spec.&nbsp; This include support for
AttributeChangeNotifdication.<br>
  </li>
</ul>
<h3>Using Gmbal<br>
</h3>
The basic usage of Gmbal is as follows:<br>
<ol>
  <li>Add annotations to existing application objects (here application
means anything you want to manage, part of GFv3 or not) to expose
attributes and operations.</li>
  <li>In some cases you may need to expose some data by defining new
methods.&nbsp; Currently all gmbal visible annotations must be public,
but I may relax that (at the cost of requiring an access check
permission for reflection).</li>
  <li>In the initialization of a module, create an appropriate
ManagedObjectManager (call it mom).&nbsp; This requires thinking about
where in the federated hierarchy the root of the ManagedObjectManager
should live.&nbsp; In some cases, this may be different depending on
the environment in which the instrumented code runs.</li>
  <li>Whenever an Object is created that requires a management
interface, register that object with the mom.</li>
  <li>Whenever an Object is no longer needed, unregister that object
with the mom.</li>
  <li>Whenever the module lifecycle ends, call mom.close() to clean up
the root object and any other remaining registered objects.</li>
</ol>
<h3>Handling Polymorphism</h3>
There are cases where an attribute has a type defined by a base class
or interface, but the actual implementation can be<br>
one of several different classes.&nbsp; For example, the ORB has a
TaggedComponent interface, representing part of the data in a<br>
remote reference, and there are several concrete subclasses of
TaggedComponent that are used.&nbsp; This is not a problem<br>
for @ManagedObject classes, since they are reference by ObjectNames,
and an ObjectName can reference any type of <br>
MBean.&nbsp; But this does not work for @ManagedData, because
@ManagedData is mapped to a CompositeData type, and<br>
CompositeData does not support polymorphism.<br>
<br>
Gmbal supports a limit form of polymorphism to handle this case using
the @IncludeSubclass annotation.&nbsp; @IncludeSubclass<br>
gives the subclasses of a @ManagedData type which themselves can
contribute attributes to the CompositeData for the<br>
parent class.&nbsp; Gmbal generates a CompositeData type that contains
the union of all fields in all of the subclasses. At runtime,<br>
only those attributes actually present in a particular instance of the
@ManagedData class are present in the <br>
CompositeData for the instance.&nbsp; In this way, gmbal supports a
limit form of polymorphism under a closed-world<br>
assumption.<br>
<h3>Issues with generic types</h3>
This is best explained with an example.&nbsp; Suppose we have
interfaces defined as follows:<br>
<pre>@ManagedData<br>public interface ExampleData&lt;S,T&gt; {<br>    S	getInfo() ;<br><br>    List&lt;T&gt; getData() ;<br>}<br><br>public interface Example&lt;S,T&gt; {<br>    @ManagedAttribute<br>    ExampleData&lt;S,T&gt; getInfo() ;<br>}<br><br>@ManagedObject<br>public interface MyBean extends Example&lt;Date,List&lt;String&gt;&gt; {<br>}<br></pre>
What sort of MBean should we create for MyBean?&nbsp; If we just use
reflection on MyBean, we find an attribute info that<br>
returns an ExampleData&lt;S,T&gt;, which would turn into a
CompositeData with two attributes:<br>
<ul>
  <li>id=info, type=Object (since type is type variable S)</li>
  <li>id=data, type=List&lt;Object&gt; (since type is List&lt;type
variable&gt;</li>
</ul>
But we acutally have a lot more information than this: if we "evalute"
the types, we should see attributes on the CompositeData like:<br>
<ul>
  <li>id=info, type=Date</li>
  <li>id=data, type=List&lt;List&lt;String&gt;&gt;</li>
</ul>
So instead of erasing the types, we evaluate the type variable by
replacing the type variables with the types used<br>
to instantiate them.&nbsp; Another way of looking at this is that
annotating a generic interface or class with @ManagedData or<br>
@ManagedObject is basically creating a template for creating the actual
CompositeData or Open MBean.<br>
<h2>Dependencies</h2>
The only dependency that gmbal has is JDK 5.&nbsp; It does not require
anything from JMX<br>
that is not in JDK 5.&nbsp; It also has no dependencies on GlassFish
v3&nbsp; or CORBA.<br>
<h2>Testing</h2>
All tests for gmbal are written in Java using JUnit, and reside in the
test directory in the project.<br>
<br>
<h2>Project Details</h2>
The gmbal project is publicly available in a mercurial workspace at <a
 href="https://kenai.com/hg/gmbal%7Emaster">https://kenai.com/hg/gmbal~master.</a><br>
Note that gmbal
will NOT be build as part of the&nbsp; GFv3 build.&nbsp; This is
necessary because gmbal is also used outside
of GFv3, and we need to avoid circular build dependencies (e.g. GFv3
dependsOn CORBA dependsOn gmbal,
which creates a build loop if GFv3 also contains gmbal).<br>
<br>
gmbal uses the following packages:<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Package
Name</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">OSGi&nbsp;
Bundle</span><br>
      </td>
      <td style="vertical-align: top;"><span style="font-weight: bold;">Purpose</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal<br>
      </td>
      <td style="vertical-align: top;">gmbal-api<br>
      </td>
      <td style="vertical-align: top;">all public interfaces<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal.util<br>
      </td>
      <td style="vertical-align: top;">gmbal-api<br>
      </td>
      <td style="vertical-align: top;">contains code needed to support
the API-Impl split (reflective construction of the implementation)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal.generic<br>
      </td>
      <td style="vertical-align: top;">gmbal-impl<br>
      </td>
      <td style="vertical-align: top;">General-purpose code for
debugging, plus simple function programming support<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">com.sun.gmbal.impl<br>
      </td>
      <td style="vertical-align: top;">gmbal-impl<br>
      </td>
      <td style="vertical-align: top;">The full implementation.&nbsp; <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
The resulting OSGi bundles are currently (version 2.0.0-b001) sized at:<br>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">gmbal-api<br>
      </td>
      <td style="vertical-align: top;">12751 bytes<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">gmbal-impl<br>
      </td>
      <td style="vertical-align: top;">123049 bytes<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
</body>
</html>
